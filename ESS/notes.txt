#controle de qualidade 
testar o sistema: escrever codigo (testes) que irão avaliar o sistema

review artifacts : outro desenvolvedor analisar o que foi feito antes de jogar no repositório.

pair programming : 2 pessoas trabalhando numa maquina nó, enquanto um programa, o outro verifica se dá tudo certo e, se necessário, dá suas opiniões.

pair programming e review artifacts sao 2 abordagens para barrar sujeira.

reduzir technical debt:
debito tecnico : codigo sujo (gambiarra) 

#specificacao requisitos

sintaticamente correto para ser executado pelo cucumber depois.

#custos

tamanho da equipe e o custo dela dado um período de tempo.

######################################

16/09

JSON :
{
	nome, idade, numseioq
}

tags:
elementos graficos, textfield, button, label, table, list.

porque commits frequentes: dando commit a cada pequena mudança fica, caso ocorra algum erro, fica mais facil identificar, qual
mudança causou o erro.

#########################
30/09
pra que criar um modulo de serviço?

porque nao nos interessa cada aluno guardar um array de aluno
mas uma lista de alunos compartilhar um array de alunos,
para isso criamos um SERVIDOR que vai compartilhar a informacao
com todos os usuarios

passando parametros para o servidor:
/alunos?nome=pedro

let é difrerente de var como?
let cria uma variavel local, aonde nao pode ser usado novamente

07/10
queremos agora enviar uma requisicao pro servidor
######################################################
09/10

^ -> começo da string
$ indica o final da string

/^asdsadda$/

browser.get("asdsda") ->o mesmo que digitar sadsada no browser.

await -> só va adiante se o browser responder (sincrono).

await$ -> existe algum atributo 'a' no qual o name = 'alunos'?, entao é nele mesmo que quero clicar
$ -> query
a -> aquele <a hajkdhasjkd> no codigo html tipo:
<a name = "alunos" routerLink...</a>

"(\d*)" casa com async(cpf)

element.all -> ele pega todos os elemenots 

('cpflist') -> todos os elementos html cujo nome é cpflist 

retorna um array de <td>'s nesse caso.

.to.evantually.equal(0) -> no caso, nao enconhar NENHUM aluno com o mesmo cpf
ele procura uma lista de alunos com aquele mesmo cpf, verificando se o length da lista é zero (achou ninguem).

Promise<String> -> feito obsevable, mas só retorna 1 elemto ao inves de uma lista;

p.then(asdsad) -> somento se a promessa for cumprida, executa sadsadsa

When: 
[^\"]* -> uma sequencia de caracteres menos ".
só tem ação nesse When.

Then -> pelo nome e cpf se to.eventually.equal(1).

################################
14/10

"${cpf}" -> pega o conteudo de cpf e transforma numa string.
`` -> permite interpolacao de string.
then -> equivale ao subscribe. quando o conteudo da requisicao chegar aoplique o .then nela.

no cenário aonde ele quer que ja exista um aluno com o mesmo cpf ele força a criaçar do dito aluno(quando tem um 'POST')
ja pe ele forçando a criação.

detalhe, se as metas estiveres preenchidas quando se espera que as metas:{} o teste irá falha.

json:true -> a resposta que chegar será transformada em json.
##################################
16/10

integracao continua: a cada novo commit eu rodo novamente todos os testes.

stub de aluno: uma classe que simula um aluno.

it -> uma propriedade que o arquiteto quer verificar.

testes de unidade: é quando se testa uma classe.
testes de servidor: " " servidor

teste de integração: testar os comportamento do cenario.(aquele do cucumber)

############################################################

21/10

os 3 tipos de teste sao necessários porque, caso haja um bug, agente ache de onde o bug está.

poucos teste de aceitação porque eles são caros pra rodar. E, caso eles falham, nós nao sabememos aonde procurar o bug.

testes de servidor sao mais rapidos e ajudam a localizar o erro.

cobertura de teste: a porção do codigo q é executada por aquele teste.

testes:
parametrizar testes: nao alimentar com valores fixos;
testes rodam independentemente dos outros testes.

como foram eliminados as redundancias nos testes de aceitacao:
ou força a eliminacao no proprio codigo do teste, ex: no caso de criar um novo aluno, limpa o sistema para nao ter nenhum aluno com o cpf.
ou fazer o codigo de tal forma pra nao ter dependencia: fazer testes de criacao com alunos de cpf diferentes por exemplo.

BDD -> primiero escreve o teste, depois escreve as features.

TDD -> antes de escrever o codigo da classe voce escreve os testes da classe.

a descricao do passo tem que descrever a semantica do codigo.

se o cenario gera dependencia, ele tem que executar uma limpeza apos cada teste. 
deleteOnExit();

teste deverá ser independente de plataforma: 
É importante que a implementação de um teste seja independente de plataforma (no sentido que o teste possa ser executado com sucesso independentemente de sistema operacional, tipo e versão de browser, idioma, etc.)










 










                           


